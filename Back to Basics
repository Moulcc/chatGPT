(56) Back to Basics: Declarations in C++ - Ben Saks - CppCon 2022 - YouTube
https://www.youtube.com/watch?v=IK4GhjmSC6w

Transcript:
(00:01) all right good morning everyone I'm Ben sacks for those of you who don't know me I'm a C plus plus trainer uh my company Saxon Associates offers training uh for companies all over the world if you guys have uh want to reach out to me later there's my email address um got a lot to get to so let's just go ahead and dive in all right so um at a very basic level computer programs are made up of entities and actions that we perform on those entities I'm using the term entity because as a generic thing to describe
(00:40) functions namespaces objects templates lots of of different things that make up our program because we can have declarations for many of those different things there are some entities that aren't declared but many of them are um and when we declare something the way that we declare it can give that that name certain properties like a type or a scope storage duration and linkage are a couple of others now not every name has all of those properties so objects for example into I that has a scope a type storage duration and linkage depending
(01:29) on where we place that declaration and um uh yeah mainly where we place it um whereas functions do not have a storage duration there's no such thing as a function that doesn't take up whose code doesn't live for the entire program um even if it's a function like a Lambda the code exists for the duration of the whole program um things like case labels for something like a go-to not that I'm suggesting you use go to's for anything but just they are still part of the language and they are useful for demonstration purposes as
(02:10) showing those just have a scope there's no type associated with them they don't take up any storage anything like that okay there's a common a common source of confusion in the language is the distinction between declarations and definitions so a declaration introduces a name into the program and provides the compiler with some information about the entity being declared not necessarily a complete set of information and it just says this name this thing's going to exist somewhere in the program
(02:50) maybe here maybe elsewhere whereas a definition gives you a complete gives the compiler I should say a complete set of information about the thing being defined and also gives its location it's right here where the definition is located so all definitions are declarations but there are declarations that are not definitions so for example here we have a function declaration it's not a definition because it doesn't have a function body we don't have we don't see the brace enclosed body here it tells us enough to know how to call
(03:35) the function again I should say that it tells the compiler enough to know how to call the function we know that it takes an INT and returns an end but there isn't any information here that the compiler can use to know or there isn't enough information here to tell the compiler how to generate the code that will actually execute the body of the function on the other hand here this is a definition for that function we have the brace enclosed body and this tells the compiler enough to actually generate the function the code to
(04:10) execute when that function is called um when we think about when we talk about objects like and I there int I is a definition we have to go little ways out of our way to get something that is actually a non-defining declaration for an object we need to use the keyword extern like in that middle example there and we we need to not provide an initializer for that value the reason being that an object definition allocates storage it tells the compiler uh and by extension the Linker where that's where this object is going to be
(04:55) located at the place where the definition exists and if we have an initializer the only way that makes sense is if we know where that value is going to be stored so this thing must be a definition whereas the the middle statement there extern into J that doesn't allocate any storage so a non-defining declaration introduces a name into the program but it's a name that if the thing that's being declared exists somewhere else not here whereas a definition gives you the full set of information which includes and here it is
(05:43) and I'm saying that that the statement here applies to functions it applies to classes and templates same distinctions applies very broadly throughout the language so let's talk a little bit about how declarations are structured and they're I'm going to do this in a series of steps now declarations can include initializers as we just saw I'm going to start off leaving the initializers out for the sake of keeping things simple so we can uh and then we will factor in the initializers a little later
(06:25) so to start off a declaration is made up basically of two parts there are what we call the Declaration specifiers one or more of those and then a declarator which is the name being declared possibly surrounded by operators um there can be and we can have a sequence of declarators in a declaration as well we can declare multiple things on one line although often we're advised not to um the name being declared there X I'm going to call the declarator ID um that's a term from the grammar of the language the uh although n there is part of the
(07:15) declarator it's not being declared and must exist must have been declared somewhere before here so a declaration specifier we can further break those down into type specifiers and non-type specifiers so type specifiers they can be keywords like int or unsigned long double Etc or they can be the names of user defined types like string again stood string we usually think of it we think of as coming from a library but from a perspective of the language it's still considered a user-defined type because it's not built in
(07:58) template specializations like a vector of long doubles that's a type specifier a non-type specifier there are a few different kinds of the of these things there are storage class specifiers like extern or static they're a function specifiers like inline or virtual and then there are a few other things like friend and type def that are sort of uh that sort of occupy this other category a miscellaneous kind of thing um so the declarator is made up of the declarator ID and then possibly some additional operators and
(08:48) those operators mean various things Star for pointer single Ampersand for L value reference what we used to call just references double Ampersand for r value reference square brackets for array and parentheses for function although as we'll see parentheses can actually mean uh two different things in declarations they can mean function they can indicate a function but they can also indicate grouping so here let's go ahead and break down this declaration here starting with the declarator this says that X is an array of n
(09:29) elements of type pointer to something and the something is being determined by the Declaration specifiers the the static unsigned long end but just the declarator just tells us X is an array of n pointers to something now static is not actually part of the type it's a declaration specifier but it doesn't really contribute to the type of X it provides other information about what x is those other properties that I talked about earlier like storage duration and linkage now how do we know that X is an array of
(10:12) pointers could it be a couldn't it be a pointer to an array we don't see pointers to a raise all that often but they do exist in the language you can write them so given that declarator how does the compiler know that that means array of pointers that that was what I had in mind well the rule is actually fairly simple the operators in a declarator go follow the same precedence order that they do when they appear elsewhere in the language so as I mentioned uh parentheses have a dual meaning here they can be used for grouping and we'll
(10:53) see some examples of that in just a moment they can also mean as grouping they have the highest precedence of all the square bracket and parentheses that indicates function that are at the next level and below that we have pointer L value reference and R value reference and so this is an array of pointers because the square bracket has a higher precedence than the star so it takes effect first X is first an array an array of what an array of pointers now parentheses as I mentioned can play two roles here there's the function call operator and
(11:44) these follow the declarator ID when I'm declaring a function the parentheses occur after the name being declared they don't contain it and that's in that case they have the same precedence as the square brackets grouping parentheses enclose the name being declared and they have the highest precedence of all and they exist because when we want they're generally used when we want to take one of those lower precedence operators and make it group more closely than one of the higher precedence operators
(12:21) so for example here f is a function that takes an INT and returns a pointer to something as given by the Declaration specifiers off to the left um again the parentheses here have a higher precedence than the star so they take effect first whereas here I've introduced some grouping parens around the star f so now the star will take effect first and F here is a pointer to a function that takes an INT and returns something that's this is why when you write a pointer to a function you have to write those parens there otherwise it means
(13:09) something different now I can put in parentheses there unnecessarily the compiler will just ignore them there there they're just surrounding F so they have no real effect f is still a function that takes a parameter of type int returns a pointer to something but this can help uh we don't typically do this intentionally but occasionally it's something that we do by accident and something and that can be this is the source of what we sometimes call the most vexing parse error uh Scott Myers referred to it
(13:45) now we can have much simpler declarations um even that end there that consists that has a declaration specifier and a declarator and is the is the full declarator it's just the name being declared and they they things can be as simple as that now the type specifiers uh type and non-type specifiers behave a little differently the type specifiers all get combined together and they collectively determine the type of the thing being declared whereas the non-type specifiers I think it makes more sense to think of them as applying directly to the name
(14:35) being declared so unsigned long and int are all type specifiers they describe the thing that the pointers in X 0.2 whereas static provides information that applies directly to X rather than being part of the type so another thing that's interesting here the order of the Declaration specifiers doesn't matter I think I usually see people write unsigned long for example but you can write long unsigned and it means the same thing as far as the compiler is concerned your co-workers might not agree with it but
(15:19) you can compile for the compiler it doesn't matter so same thing here however I order those three type specifiers those are all declaring the same kind of thing in C plus plus now const is a type specifier this is something that people sometimes get confused about um it's it mixes in with the other type specifiers so X there is b or sorry V there is being declared as an array of end pointers to constant integers it's not that V itself is constant it's that the things that the pointers point to must be treated as const
(16:09) so that's a um this is a source of confusion for some people but const is considered to be a type specifier now const and volatile are sort of unusual in that they're the only symbols in C plus plus that can appear either as declaration specifiers or as part of the declarator so there again order of Declaration specifiers doesn't matter the compiler those two declarations both mean the same thing endpoint array of n pointers to integers that are const whereas here const is part of the declarator it's on the right hand side
(16:55) of the star and now the const is modifying the pointer this is an array of n constant pointers to integers which are non-const so a const appearing to the immediate right of a star declares a point declares something that really is a constant pointer that is the um where it points is fixed at the time of defiant of defining the object the things that it points to are not necessarily const but we can't change the locate the memory address that the pointer points to and I think that there's only one real one way to write
(17:46) these things I mean I guess I can write them all in the I can write uh there's only one real way to write this uh pointer I can't reorder any part of that and pointers are kind of unusual along with references in that you can think of them as reading from right to left they um CPW is a constant pointer to a widget here pcpw is a pointer to a constant pointer to a widget and here CPW is a constant pointer to a pointer to a widget I think it's a rule that scales up relatively nicely and if I want to declare those things
(18:35) that's how I have to declare them um now technically the star and the const are separate tokens the compiler doesn't care how I space things around there um but when it processes them the compiler essentially combines them together into the const pointer operator it has the same precedence as a plane star would in a in a declarator now um I'm realizing suddenly that I forgot my my East const armband here um so because I am going to take a moment to advocate for why I think that that why it makes the East Coast socile
(19:27) makes things easier to understand um I can I think that the the easiest way to make sense out of declarations involving cost or volatile is first go ahead and write the Declaration leaving out the constant volatile and then simple rule put con store volatile to the immediate right of whatever it is that you want those terms to modify so if we want X to be an array of n constant pointers to volatile uint32s we can start by just writing it as array of n pointers to Unit 32 like that and then we can go ahead and add in and
(20:14) then here same declaration I've just added space for the CV qualifiers that I'm about to add in we want the pointer to be constant the pointer as I should say since it's an array to be constant so we add the const to the immediate right of the star there and then the things that they point to are meant to be volatile so you went 32t volatile star const X square bracket n I tend to think that that's an e a fairly simple rule for knowing how to structure these declarations now in some ways I'm it's
(20:54) easy for me to say that yeah if you have a lot of code that's written in a different style in the const west Style yeah I'm not necessarily saying you have to change everything tomorrow but I think that underst that that at least helps clarify what the meaning is even if you continue to write things in the other Style Okay so um now adding in the initializers like I said I would earlier um the initializer for a declaration can appear in a few different ways um we can write the equals initializer for what is sometimes called copy
(21:41) initialization although it's not really not necessarily really making a copy there we have the parenthesized initializer with some termed direct initialization and then we have the braces for braced initialization now declarations can consist of it can declare more than one thing let's say we can declare more than one thing on the same line again often we don't but the language does let us do this and it's worth knowing at least a little bit about how the language makes sense out of that um the rule is each of the declarators is
(22:26) separate the Declaration specifiers the things off to the left those are shared between them but each declarator is treated independently and they can have an initializer or they can not have an initializer so here f is declared as a function with a parameter of type int that returns the thing designated by the shared declaration specifiers which here is just int n is an object of type int being initialized with the value 42.
(23:06) using the equal sign form of initialization and here p is an object of type pointer to int because it's got the star in it being initialized with the address of n is one of the reasons why people often separate things out onto multiple lines is because the idea that this is actually declaring three things of three different types something that that a lot of people find confusing and I don't know that and I can understand why um and it's my job to know this stuff so it's uh but for those of us who have to
(23:47) you know get the release out on Friday we have other things to worry about um okay talking about const and const expert here so I mentioned before that these are equivalent um whether I write the order write them in the order const chart or Char const these two declarations mean the same thing now const export is also a declaration specifier and again since the order of Declaration specifiers doesn't matter to the compiler whether I write it as const expert Char star P or Char const expert star p pyware doesn't care
(24:36) most of us write the const expert on the left and um and I think including me even though I typically write my con use the East Coast style and there's a reason for that which is that these are not equivalent um this is something that comes that can come as a surprise to people constant const expert have different semantics in this sense a const uh a pointer that's declared const expert is really more like a const pointer than it is like a pointer to const um here in both of these cases P the thing that P points to
(25:21) is non-modifiable it's always going to point to the same location but the value at that location we can use P to change it so now the the requirements on how we initialize these things are a little bit different context per has slightly more stringent requirements so const expert is not really a type specifier it's a declaration specifier but it's not a type specifier it behaves more like the non-type specifiers like static and typically replace those far off to the left so that's what I tend to recommend doing
(26:04) as well again we think of it more as if it's modifying X directly then contributing to the type of x and getting mixed in with the others so here X is the const expert declaration excuse me the const expert declaration is more or less equivalent to the cost declaration to the cons the array of const pointers declaration down at the bottom with the additional requirement that the initializer for for the const expert expression needs to be a compile time constant expression const expert requires that the uh that
(26:57) the initializer be known at compile time whereas some things that are simply const the initializer can be an expression that resolves at runtime okay um so the keyword type name is can be has a few different places that we can use it in the language I tend to prefer to write my templates like this where I declare the type parameters using the keyword type name so template type name t type name p class widget now here I could use the keyword com keyword class there instead that's all I get for talk about cons for
(27:49) the last 10 minutes you start going on auto pilot yeah you can use the keyword class there to declare tnp in template parameter lists in this place uh class and type name are interchangeable there's another use for type name where only type name will do and that's what I'm about to explain here all right so the compiler processes templates in two phases as we say um the very first time that the compiler sees a template like this when it's just encountering the Declaration of here we have a function template
(28:42) um it doesn't know what T is going to be yet in fact if we've written this as a function template probably it's because T is going to be several different things and we expect to have several different versions of this function generated from the template throughout the program in any case the compiler upon seeing this doesn't know what T is going to be yet so it can't generate the code for the function Foo even though what we're seeing here is a the body of a function template without knowing what T is the compiler
(29:21) can't generate the code for that body now the compiler still tries to do some error checking during that during that first phase when it's reading through the definition of the function template here tries to do as much as it can as it can to report errors during that first phase as possible and then later on the second phase occurs when the compiler actually encounters a call to a function to that function template at which point the compiler deduces the type from the function argument or the type could be explicitly specified
(30:04) um either way that's when the second phase of template translation occurs because now the compiler knows what the other type argument for T will be it can go ahead and substitute that into the body of the function and finish out doing the rest of the semantic analysis as part of generating the code for that specific version of the function template so the first phase is when the compiler parses the template declaration itself and that happens once whereas the second phase occurs when the compiler is actually
(30:47) instantiating the template for a specific template argument or set of template arguments if we're talking about something that has multiple template arguments and that can happen several times because in the program we can have several different places where we instantiate the template so the stand um the understanding that two-phase translation approach is um is the basis for why the key name the keyword type name is required in some places in C plus plus so the standard Library container class container types like string well string
(31:39) is considered a temp a container although we don't usually you know often we think of vector list map Etc but string actually counts as well um all of those container types have member types that they declare inside themselves and some of them also have member constants so all of the container types for example declare a nested type called size type usually it's an alias for something like size t the string class template string is actually an instantiation of an underlying template called basic string
(32:19) um as you may have seen in error messages string has a nested constant called n pause represents the the sort of a location where the location when we searched for something and couldn't find it in a string um we need the keyword type name when we're using the member types like size type in a template context so here this is a a first attempt at writing a template and I've left out the keyword type name here and I'm gonna we're going to see why that turns out to be necessary when writing this code so the the idea here
(33:07) behind the munge function is that it's meant to T is meant to be some string a string or some string like type that has a size type member type and an end pause member constant in this situation so this time this template expects both of those things to be properties of t but again the compiler only knows what T is during that second phase of template translation um it won't know that the first time that it during the first phase of translation all it knows is that t represents a type it can't see what T is going to be so it
(33:56) can't see what T colon colon size type and T colon colon end pause are going to be at that point either and without knowing those things the compiler can't tell that t cold colon size type is meant to be a type whereas npaz is meant to be a constant that information only becomes available during the second phase of template translation so let's think about what does that line of code represent how does the meaning of that line of code change there depending on whether or not size type and end pause are both types or
(34:43) something else so if they're both types what is that statement saying it's a function declaration because uh I is the name of the function it's a function that takes a parameter of Type n pause where n positive is a member type of t and returns back a pointer to size type the type the size type that belongs to T that's if they're both types now if size type is a type and end pause is something other than a type a constant object function something like that which is what the situation that we originally
(35:34) had in mind here when we wrote when we or whoever it was wrote the munge function then this is an object definition we're creating an object called I with the value end pause being initialized with the value and pause of type pointer to G Co and colon size type now if neither one of them is a type what do we have then it's a multiply expression I guess I mean it's it's there's a good chance that it does that that doesn't compile at all depending on exactly what what non-type things and pause and size type are
(36:30) um even if it is a multiplier expression it's probably not very useful because usually we don't multiply things and then just do nothing with the result but the compiler would be willing to accept that as if would be willing to read that if both of those things were non-types as okay well I is the name of a function that's being invoked and being past the value and pause as the right argument as the right operand of a multiply where size type is the left operand of the multiply I say I could be a function it could
(37:09) also be a function like cast something like that so the meaning of that line of code changes depending on whether or not size type and end pause are types or not so in order to make sense out of that line during the first phase of template translation in order to do the kinds of error checking that we want the compiler to be able to do during the first phase of translation the compiler needs to know whether those dependent names as we call them the idea is that the values the meanings of size type and end pause depend on
(37:57) what T ultimately turns out to be those dependent names might mean something different each time the template is instantiated theoretically there's nothing that that prevents me from writing that code in such a way that sometimes theoretically um with if not for the keyword type name I could write that code so that sometimes that without comes out to be an object declaration and sometimes it's a function declaration and so forth um and whereas names like other names in the function template manager are non-dependent names those are names that
(38:44) mean the same thing in every function every instantiation of the function um whereas dependent names those are going to depend on what to substitute that substituted in for t so in order to make sense out of that munge function the compiler needs to know whether something like T colon colon size type is a type name or something else and all that really matters is whether it's a type name or something else doesn't care if the compiler knows it's not a type name then it'll figure out the rest of the details
(39:24) during the second phase of template translation but it's important for error for the kinds of error checking that we want the system to be able to do that we want the compiler to give us to know whether something is a type name or not because type names knowing that something is a type name makes it clear that we're declaring something can make the difference between declaring something and writing something like a multiply expression so a name in a template declaration that that is dependent on a template
(40:07) parameter so when we have a dependent name it's assumed not to name a type unless we explicitly say that it's a type by qualifying it with the keyword type name so the assumption is that something that like T colon colon size type or t colon colon end pause is not a type and we have to explicitly say if it is so if we want to write our Munch function the way that we'd originally intended we have to use the keyword type name in those two places preceding the use the two uses of T colon colon size type
(40:51) to make it clear that that's meant to be a the name of a type whereas T colon colon end pause that's the name of we're thinking about it as a constant but it could be a a static data member or something else either way um we know that that that thing is declaring something called I because we know that size type is a type name so on line one there the key word we're using the keyword type name that's a place where we could be using the keyword class instead it tells that's telling the compiler
(41:38) that that template parameter is a type there's a type argument as opposed to some non-type argument um whereas on lines two and three the keyword type name there is making it clear that we intend for T colon colon size type to be considered a type name we can substitute the keyword class on line one but not on lines two and three only type name will do there okay last section there's this I mentioned before that the double Ampersand in a declarator usually means r value reference before I I said it means our value
(42:32) reference now I'm going to qualify that statement a little bit in a declaration like the do it function there um ARG is being declared as an R value reference to a string and an R value reference has to bind to an R value so the strings S1 and S2 there are L values they're long-lived objects that have locations in memory where they live for whatever for the duration of time that they're um that's associated with their definition so I would not be able to call do it and pass simply S1 in but S1 plus S2 that's an expression that
(43:19) yields an R value I can go ahead and call do it on S1 plus S2 however there are some cases where the unary uh double Ampersand in a declarator means forwarding reference rather than r value reference and this is a term that was you that's used in the standard um so here in this template declaration ARG is being declared to be a forwarding reference to a T rather than an R value reference to a T unlike an R value reference a forwarding reference can bind to either an L value or an R value so we use forwarding references the name
(44:14) forwarding reference comes from the fact that they're often used to write what we call forwarding functions functions that take their arguments and pass them along directly to another function maybe one of several functions depending on what the forward forwarding function is doing the idea is that it that the forwarding function well four words its arguments along to someone else the same way that you might forward an email to someone now a forwarding reference conceptually remembers whether it's bound to an L value or to
(44:52) an R value the reason that we uh use a forwarding reference like this is because we want to preserve the information about whether something the thing that was passed in to the first function the forwarding function is an L value or an R value so that we can forward that information Along by calling to the function that is being called the forwarded to function using the stood forward uh helper function um yes I know that I'm saying the word forward an awful lot here um I apologize but it's a bit of a necessity
(45:31) um to pass that knowledge along because the function that we are forwarding to knowing whether something is an L value or an R value can be important for performing certain kinds of optimizations like whether or not we can safely use move semantics that's that's the case only if we have something that's really an R value then we're then it becomes safe to move from so looking back at this example I said that ARG is a forwarding reference here now it's a forwarding reference rather than an R value reference
(46:12) because it fits two criteria it doesn't have any CV qualifiers it's not declared conster volatile the rule the rule is if it's got a cost or a volatile in it can't be a forwarding reference must be an R value reference at that the second rule is that ARG appears in a deduction context that's what and that makes it possible for it to be a forwarding reference so the type t on that line is something that may be deduced based on the the argument passed to dispatch that's also a necessary condition for
(46:56) this to be a for for ARG to be a forwarding reference here so as I said a forwarding reference can't be const or volatile so for example here ARG one is a forwarding reference but similar declaration that includes the word const in the Declaration of ARG II that is an R value reference always specifically it's an R value reference to const we don't often use r value references to const they're not terribly helpful usually the reason that we want an R value reference is because um we want to identify something as an R
(47:40) value so that we can safely move from it and we can't move from something that's const but the language does allow you to write them and if we were to write this we'd be saying specifically that org2 is an R value reference to const and then as I mentioned uh forwarding references can only something is only a forwarding reference if it appears in what we call a deduction context so ARG in the the function dispatch that I showed you earlier there the T in that on that line of code can be deduced from a template argument
(48:23) depending on how dispatch is being called so if I pass three to dispatch the type is to do the type T is deduced to be int if I pass in 3.5 the type is deduced to be double instead so that's what I mean when I say a deduction context now it's easy to think that that means okay if it's in a template it's a it's a deduction context but that's not necessarily the case here we have a line that's inside the function template that looks similar but here although ARG is a forwarding reference
(49:04) temp is an R value reference because it doesn't appear in a deduction context the argument for T the type argument was set when dispatch was called by the way that the function was called from the outside the function the code in there is not going to do anything to change the meaning of t so once we know what our what ARG is and our or is a reference to we know that temp is an R value reference to that same kind of thing similarly here we have a class template that has a member function that takes in this case on r value reference and
(49:59) it's an R value reference because the type argument for T there is set when we create the object of oh dear uh my computer just crashed on me here apparently okay um yeah it's it's rebooting it should be back up in just a moment but as I was saying um the the type argument there when we are talking about a class template the type argument is set when we create the object of that class type of that by instantiating that class template so I had an I had a Class Type um C that was all right thank you for bearing with me here
(51:15) um I think that's like the second time this computer has ever crashed it's not that so of course it happens here um yeah so here when I create that object little C that's where T gets locked in as being it regardless of of how I of what I pass to a call to C dot MF T isn't it was set when I created little C there so uh so that function is going to accept an R value reference to an it always now a deduction context doesn't necessarily have to be inside a template a declaration that uses the keyword Auto
(52:15) also establishes a deduction context so this can appear out these can appear outside of templates they still create deduction contexts R1 is an R value reference to an INT whereas R2 is an R value referenced to a double these could also appear inside templates and they would also establish a deduction context if they appeared inside a template wherever they appear it's a deduction context okay that brings me to the end um so now I'm happy to take questions if anyone has them ah great talk uh I was wondering and what in which
(53:01) cases if any does uh const applied to a very sorry const expert applied to a variable imply either const or static in what cases does it apply does it imply const or static when you declare something to be const expert yeah um so it's um I'm scrolling back here to where I was talking about const expert because I I'm uh so if I tried to add in um I suppose I'm not entirely sure what you mean to some extent so um I could add so
(54:05) I could declare because those top two are not equivalent I could declare something to be Char const expert to be const expert Char const star P if I wanted to the cost wouldn't be redundant there because what I would be declaring would be I'd be saying that the pointer is const expert it's um it's always going to point to the same location and the initializer for that expression needs to be a compile time constant expression and the and if I have and then the const would apply to the to the type being pointed
(54:45) to it would be saying that the character that the pointer points to I don't have permission to change it um whereas uh there'd be no need in the uh writing something like const expert Char star const p um adding the const expert to the bottom line there would be redundant um so I um I can't think of a k Obe yeah static ever not redundant coupled with consists I don't when you when you have something that's it's static not redundant there are lots of different uses of the keyword static so I'm tempted to say that
(55:47) um there are certainly places where if you don't use the keyword static um it doesn't the compiler just won't make sense out of something like you can't have a const expert data member of a class type that is not static the keywords you'd be required to add the keyword static there it wouldn't Simply Be implied by the presence of the const expert um does that does that answer your question is the cons is the const ever not redundant and you're saying if we're not talking about pointers or uh multi-level
(56:32) types I can't think of a case where it's not um I guess I would say that there's um it's worth noting that there's a difference between a const expert member function and a const member function um the originally in C plus 11 const expert member functions were implicitly const member functions but they changed that rule when we went to C plus plus 14 so you can have const expert member functions member functions that fear that theoretically return something that's a compile time constant expression
(57:20) um but don't promise not to modify the thing on which they are called it's not that common but it happens I guess that's the the situation where that I can think of that most resembles the const and the const expert not being redundant there foreign no I don't for a variable like I can't think of a case where or for an object I can't think of a case where declaring something you need to declare something both const and const expert yeah we have a question online uh when using Auto Ampersand Ampersand can an L
(58:06) value be passed to an R value can an R value be or so can an L value be passed to an R value when using um Auto Ampersand Ampersand um so what you're so you're what you're referring to here is um on the last slide I showed that you can write uh this um oh yeah sorry this is uh this is not being I showed that you can write this um and you're saying uh uh can that be can I write this as well and yes I can
(59:19) um that is also valid in C plus plus and this is because again what I'm declaring here R1 and R2 are forwarding references so they can bind to either L values or R values and they follow a rule called reference collapsing um where R2 will essentially will essentially be an L value will wind up being something very akin to an L value reference to an end whereas R1 will wind up being very much akin to an R value reference to an end and that's the sense in which I said earlier that forwarding references sort
(59:59) of remember what they are bound to question um in one of your slides you had uh three different types of variable initializations with an assignment operator with parentheses and with braces can you describe advantages or disadvantages to each of those types yeah so um so here um between the so the brace initialization I think is the is probably the one I would say is most distinct there um because the when you use the brace initialization um so in this case here um there is uh with an INT um there's one primary difference which is
(1:01:01) that uh the the braces prohibit narrowing conversions whereas the other two would not so if I wrote if I tried to write 42.5 there um the first two lines would compile just fine maybe with a warning whereas the third line I would be required to give me an explicit error uh because I'd be doing a conversion that discards information there um in the case this doesn't come up in the case of an inch but if I were declaring something like a vector the braces are also assumed uh to mean uh initializer list uh to be referred to
(1:01:45) be creating an uh saying that the vector should be initialized with this collection of values um whereas uh using the parenthesis in that situation to be that would be taken to mean call a Constructor that takes a single parameter of this type an initializer list is still a single parameter but it would be assumed to mean initializer list of one element in that uh in the case of the braces as far as differentiating between the top two go um the main distinction I can think of is if there were a conversion involved
(1:02:28) there if we were talking about it doesn't really apply for INS but if we were talking about a class type with a um with a converting Constructor um the uh the if the conversion were declared explicit um only the second line there would be permitted I think we are out of time so I'm happy to to continue taking questions uh out in the hall after this but I need to make room for the next speaker so thank you for coming hope you guys found it useful and
